<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Bootstrap demo</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.7/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-LN+7fdVzj6u52u30Kp6M/trliBMCMKTyK833zpbD+pXdCLuTusPj697FH4R/5mcr" crossorigin="anonymous">
</head>

<body>
    <div class="container mt-5">
        <div class="row">
            <div class="col-md-6">
                <textarea name="" id="textArea" class="w-100 form-control"></textarea>
            </div>
            <div class="col-md-6 border rounded">
                <div id="markdownDisplay">

                </div>
            </div>
        </div>
    </div>

    <script>
        const textArea = document.getElementById('textArea');
        const markdownDisplay = document.getElementById('markdownDisplay');

        textArea.addEventListener('keyup', (event) => {
            
            parseTextToMarkdown(textArea.value);
            // console.log(textArea.value, event.key);
        });
        const headingTokens = ['#', '##', '###', '####', '#####'];
        const boldRegex = /\*(.?)\*/gm;

        function parseTextToMarkdown(value) {
            // let's break the text on the basis of '\n'
            let sentences = value.split('\n');
            
            sentences = sentences.map(v => v.concat('<br />'));
            
            for (let index = 0; index < sentences.length; index++) {
                let firstToken = sentences[index].split(' ')[0];
                // handle heading
                if (sentences[index].startsWith('#')) {
                    if (headingTokens.includes(firstToken)) {
                        const [openingTag, closingTag, sentenceStartIndex] = getHTMLTagsForHeading(firstToken);
                        let newSentence = `${openingTag} ${sentences[index].substring(sentenceStartIndex)} ${closingTag}`;
                        sentences[index] = newSentence;
                    }
                    continue;
                }

                // Handle unordered list
                if (sentences[index].startsWith('- ')) {
                    let newSentence = `<li> ${sentences[index].substring(2)} </li>`;
                    sentences[index] = newSentence;
                }

                // handle bold phrases
                let allBoldPhrases = sentences[index].match(/\*(.*?)\*/gm);
                if (allBoldPhrases) {
                    let newSentence = sentences[index];
                    for (let boldPhrase of allBoldPhrases) {
                        newSentence = newSentence.replace(boldPhrase, `<b>${boldPhrase.substring(1, (boldPhrase.length - 1))}</b>`);
                    }
                    sentences[index] = newSentence;
                }

                // handle italics phrases
                let allItalicsPhrases = sentences[index].match(/_(.*?)_/gm);
                if (allItalicsPhrases) {
                    let newSentence = sentences[index];
                    for (let italicsPhrase of allItalicsPhrases) {
                        newSentence = newSentence.replace(italicsPhrase, `<i>${italicsPhrase.substring(1, (italicsPhrase.length - 1))}</i>`);
                    }
                    sentences[index] = newSentence;
                }

                // handle linked phrases
                let candidatesForLinkedPhrases = sentences[index].match(/\[(.*?)\]\((.*?)\)/gm);
                if (candidatesForLinkedPhrases) {
                    let newSentence = sentences[index];
                    for (let linkedPhrase of candidatesForLinkedPhrases) {
                        let [onlyPartInsideSquareBraces, onlyPartInsideRoundBraces ] = ['', linkedPhrase.match(/\((.*?)\)/gm)[0]];
                        // first check if there is any more occurrences of [] in the phrase
                        const partsInsideSquareBraces = linkedPhrase.match(/\[(.*?)\]/gm);
                        if(partsInsideSquareBraces && partsInsideSquareBraces.length > 1) {
                            // last one should be link rest all will be dummy
                            onlyPartInsideSquareBraces = partsInsideSquareBraces[partsInsideSquareBraces.length - 1];
                            linkedPhrase = onlyPartInsideSquareBraces + onlyPartInsideRoundBraces;
                        }
                        else {
                            onlyPartInsideSquareBraces = linkedPhrase.match(/\[(.*?)\]/gm)[0];
                        }
                        let href = `<a href='${onlyPartInsideRoundBraces.substring(1, (onlyPartInsideRoundBraces.length - 1))}' target="_blank">${onlyPartInsideSquareBraces.substring(1, (onlyPartInsideSquareBraces.length - 1))}</a>`;
                        newSentence = newSentence.replace(linkedPhrase, href);
                    }
                    sentences[index] = newSentence;
                }

                // handle image linked phrases
                let candidatesForImageLinkedPhrases = sentences[index].match(/\!\[image\]\((.*?)\)/gm);
                if (candidatesForImageLinkedPhrases) {
                    let newSentence = sentences[index];
                    for (let imageLinkedPhrase of candidatesForImageLinkedPhrases) {
                        let [onlyPartInsideSquareBraces, onlyPartInsideRoundBraces ] = ['', imageLinkedPhrase.match(/\((.*?)\)/gm)[0]];
                        // first check if there is any more occurrences of ![image] in the phrase
                        const partsInsideSquareBraces = imageLinkedPhrase.match(/\!\[image\]/gm);
                        if(partsInsideSquareBraces && partsInsideSquareBraces.length > 1) {
                            // last one should be an image rest all will be dummy
                            onlyPartInsideSquareBraces = partsInsideSquareBraces[partsInsideSquareBraces.length - 1];
                            imageLinkedPhrase = onlyPartInsideSquareBraces + onlyPartInsideRoundBraces;
                        }
                        else {
                            onlyPartInsideSquareBraces = imageLinkedPhrase.match(/\!\[image\]/gm)[0];
                        }
                        let img = `<img style='width: 100%; height: auto' src='${onlyPartInsideRoundBraces.substring(1, (onlyPartInsideRoundBraces.length - 1))}' alt='${onlyPartInsideSquareBraces.substring(1, (onlyPartInsideSquareBraces.length - 1))}' />`;
                        newSentence = newSentence.replace(imageLinkedPhrase, img);
                    }
                    sentences[index] = newSentence;
                }
            }
            markdownDisplay.innerHTML = sentences.join(' ');
        }

        // utility functions
        function getHTMLTagsForHeading(token) {
            switch (token) {
                case '#':
                    return ['<h1>', '</h1>', 2];
                case '##':
                    return ['<h2>', '</h2>', 3];
                case '###':
                    return ['<h3>', '</h3>', 4];
                case '####':
                    return ['<h4>', '</h4>', 5];
                case '#####':
                    return ['<h5>', '</h5>', 6];
                default:
                    return []
            }
        }

        // Tests
        // sunny side up scenario
        let val = `
## My heading
Some normal text and we have some *bold text after _that*  the line_ does not ends here though. Still we have some words before the line actually breaks
and we start an _italic phrases._ We should not consider - or # when they are in between sentences and only consider them when they are on the new line 


- I Wonder how challenging this could get. All this is possible [due] to [google](https://www.google.com/) ✌️. 
- Bulleted points and then numbered points and quotations all could really get messy soon
`;
        // parseTextToMarkdown(val);
// val='![image] [link](https://www.google.com) ![link] (https://www.google.com) ![image](https://i.postimg.cc/0Np34PnL/code-journal.jpg)';
// parseTextToMarkdown(val)
    </script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.7/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-ndDqU0Gzau9qJ1lfW4pNLlhNTkCfHzAVBReH9diLvGRem5+R9g2FzA8ZGN954O5Q"
        crossorigin="anonymous"></script>
</body>

</html>